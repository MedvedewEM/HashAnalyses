В данной главе приведено подробное описание следующих хеш-функций:
\begin{enumerate}
\item MD5 (сокращение от Message Digest 5)
\item ГОСТ Р 34.11-2012 (выходное значение - 512 бит)
\end{enumerate}
\subsection{Алгоритм MD5 вычисления хеш значения}
\begin{enumerate}
\item Входное сообщение $M \in \{0, 1\}^l (l \geq 0$) представляется в виде
\begin{center}
$m_0m_1 \dots m_{l-1}$
\end{center}
и дополняется битами до общей длины, сравнимой с 448 по модулю 512, следующим образом: добавляется бит ''1'', а затем остальные биты ''0''.\\
Входное сообщение должно обязательно дополняться, даже если его длина кратна 448 по модулю 512.
\item Далее сообщение дополняется 64-мя битами - длиной исходного сообщения в битовом представлении. Если его длина сообщения больше, чем $2^{64}$, то берутся первые 64 бита (меньшей разрядности). После двух первых шагов должны получить сообщение с длиной $N$, кратной 512.
\item Основная часть алгоритма использует так называемый md-буфер - четыре 32-х битных слова (A, B, C, D) со следующими начальными значениями (представлены в 16-тиричной системе счисления):
\begin{center}
A = 01 23 45 67,\\
B = 89 AB CD EF,\\
C = FE DC BA 98,\\
D = 76 54 32 10
\end{center}
\item Определим четыре функции:
\begin{center}
$F, G, H$ и $I(X, Y, Z) : \{0, 1\}^{32} \times \{0, 1\}^{32} \times \{0, 1\}^{32} \rightarrow \{0, 1\}^{32}$
\end{center}
\begin{center}
$F(X, Y, Z) = X \wedge Y \vee \neg X \wedge Z $\\
$G(X, Y, Z) = X \wedge Z \vee Y \wedge \neg Z$\\
$H(X, Y, Z) = X \oplus Y \oplus Z$\\
$I(X, Y, Z) = Y \oplus (X \vee \neg Z) $\\
\end{center}
\item Инициализируем вспомогательный массив T[i] $, 0 \leq i \leq 63$:
\begin{center}
$T[i] = int(2^{32} * \abs{ sin(i) })$
\end{center}
\item Далее следует 4 раунда, описанные в псевдокоде ниже:\\\\
For i = 0 to N/16 - 1 do\\
\tab For j = 0 to 15 do\\
\tab \tab X[j] := M[16*i + j]\\\\
\tab AA = A;\; 
\tab BB = B;\; 
\tab CC = C;\; 
\tab DD = D;\; \\\\
\tab // Раунд 1\\
\tab // Пусть [abcd k s i] обозначает следующее преобразование:\\
\tab // a = b + ((a + F(b, c, d) + X[k] + T[i]) < < < s)\\\\
\tab $[ABCD\; \; 0\; \; 7\; \; 1]\; \; [DABC\; \; 1\; \; 12\; \; \; 2]\; \; [CDAB\; \; 2\; \; 17\; \; 3]\; \; [BCDA\; \; 3\;\;  22\; \; 4]$\\
\tab $[ABCD\; \; 4\; \; 7\; \; 5]\; \; [DABC\; \; 5\; \; 12\; \; \; 6]\; \; [CDAB\; \; 6\; \; 17\; \; 7]\; \; [BCDA\; \; 7\;\;  22\; \; 8]$\\
\tab $[ABCD\; \; 8\; \; 7\; \; 9]\; \; [DABC\; \; 9\; \; 12\; 10]\; \; [CDAB\; 10\; 17\; 11]\; \; [BCDA\; 11\; 22\; 12]$\\
\tab $[ABCD\; 12\; 7\; 13]\; \; [DABC\; 13\; 12\; 14]\; \; [CDAB\; 14\; 17\; 15]\; \; [BCDA\; 15\; 22\; 16]$\\\\
\tab // Раунд 2\\
\tab // Пусть [abcd k s i] обозначает следующее преобразование:\\
\tab // a = b + ((a + G(b, c, d) + X[k] + T[i]) < < < s)\\\\
\tab $[ABCD\; \; 1\; \; 5\; 17]\; \; [DABC\; \; 6\; \; 9\; 18]\; \; [CDAB\; \; 11\; \; 14\; \; 19]\; \; [BCDA\; \; 0\;\;  20\; \; 20]$\\
\tab $[ABCD\; \; 5\; \; 5\; 21]\; \; [DABC\; 10\; 9\; 22]\; \; [CDAB\; \; 15\; \; 14\; \; 23]\; \; [BCDA\; \; 4\;\;  20\; \; 24]$\\
\tab $[ABCD\; \; 9\; \; 5\; 25]\; \; [DABC\; 14\; 9\; 26]\; \; [CDAB\; 3\; 14\; 27]\; \; [BCDA\; 8\; 20\; 28]$\\
\tab $[ABCD\; 13\; 5\; 29]\; \; [DABC\; \; 2\; \; 9\; 30]\; \; [CDAB\; 7\; 14\; 31]\; \; [BCDA\; 12\; 20\; 32]$\\\\
\tab // Раунд 3\\
\tab // Пусть [abcd k s i] обозначает следующее преобразование:\\
\tab // a = b + ((a + H(b, c, d) + X[k] + T[i]) < < < s)\\\\
\tab $[ABCD\; \; 5\; \; 4\; \; 33]\; \; [DABC\; \; 8\; \; 11\; \; \; 34]\; \; [CDAB\; \; 11\; \; 16\; \; 35]\; \; [BCDA\; \; 14\;\;  23\; \; 36]$\\
\tab $[ABCD\; \; 1\; \; 4\; \; 37]\; \; [DABC\; \; 4\; \; 11\; \; \; 38]\; \; [CDAB\; \; 7\; \; 16\; \; 39]\; \; [BCDA\; \; 10\;\;  23\; \; 40]$\\
\tab $[ABCD\; \; 13\; \; 4\; \; 41]\; \; [DABC\; \; 0\; \; 11\; 42]\; \; [CDAB\; 3\; 16\; 43]\; \; [BCDA\; 6\; 23\; 44]$\\
\tab $[ABCD\; 9\; 4\; 45]\; \; [DABC\; 12\; 11\; 46]\; \; [CDAB\; 15\; 16\; 47]\; \; [BCDA\; 2\; 23\; 48]$\\\\
\tab // Раунд 4\\
\tab // Пусть [abcd k s i] обозначает следующее преобразование:\\
\tab // a = b + ((a + I(b, c, d) + X[k] + T[i]) < < < s)\\\\
\tab $[ABCD\; \; 0\; \; 6\; \; 49]\; \; [DABC\; \; 7\; \; 10\; \; \; 50]\; \; [CDAB\; \; 14\; \; 15\; \; 51]\; \; [BCDA\; \; 5\;\;  21\; \; 52]$\\
\tab $[ABCD\; \; 12\; \; 6\; \; 53]\; \; [DABC\; \; 3\; \; 10\; \; \; 54]\; \; [CDAB\; \; 10\; \; 15\; \; 55]\; \; [BCDA\; \; 1\;\;  21\; \; 56]$\\
\tab $[ABCD\; \; 8\; \; 6\; \; 57]\; \; [DABC\; \; 15\; \; 10\; 58]\; \; [CDAB\; 6\; 15\; 59]\; \; [BCDA\; 13\; 21\; 60]$\\
\tab $[ABCD\; 4\; 6\; 61]\; \; [DABC\; 11\; 10\; 62]\; \; [CDAB\; 2\; 15\; 63]\; \; [BCDA\; 9\; 21\; 64]$\\\\
\tab A += AA;\; B += BB;\; C += CC;\; D += DD;\\
\item Финальным результатом будет являться строка $A_{1}B_{1}C_{1}D_{1}$, где $X_{1}$ - это $X$ начиная с младших бит. $X \in \{A, B, C, D\}$
\end{enumerate}
\textbf{Замечание 3.} Операция < < < обозначает циклический сдвиг битов влево.
\subsection{Алгоритм ГОСТ Р 34.11-2012 вычисления хеш значения}
\begin{enumerate}
\item Инициализируем вспомогательные переменные для алгоритма:
\begin{center}
$h := 0^{512} \in \{0,1\}^{512}$\\
$N :=0^{512} \in \{0,1\}^{512}$\\
$EPSILON := 0^{512} \in \{0, 1\}^{512}$
\end{center}
\item While $\abs{M} \geq 512$:\\
\tab * Разложим сообщение M в виде M' || m, где m $\in \{0, 1\}^{512}$ *\\
\tab h := round(h, m, N)\\
\tab N := N + 512 (mod $2^{512}$)\\
\tab EPSILON := EPSILON + 512 (mod $2^{512}$)\\
\tab M := M'
\item Дополним сообщение M, полученное на втором шаге, следующим образом: добавляется бит ''1'', а затем остальные биты ''0'' так, чтобы получилось сообщение длины 512. Сохраним полученное сообщение в m.\\
h := round(h, m, N)\\
N := N + $\abs{M} (mod 2^{512}$)\\
EPSILON := EPSILON + $\abs{m} (mod 2^{512}$)\\
h := round(h, N, 0)\\
h := round(h, EPSILON, 0)\\
\item Полученное значение h и есть финальный результат хеш-функции.\\\\
\end{enumerate}
\textbf{Обозначения:} Далее используются следующие обозначения:\\
$a \in \{0, 1\}^n$ и $b \in \{0, 1\}^n \Rightarrow$ a || b $\in \{0, 1\}^{2n}$- их конкатенация. \\
$LP(x)$ - композиция преобразований L и P. P применяется первым.\\\\
Для определения функции round(h, m, N), которая используется в предыдущем алгоритме, нам понадобятся дополнительные преобразования:
\begin{itemize}
\item Преобразование X: побитовое исключающее ИЛИ (XOR) двух векторов одинаковой длины.
\item Преобразование S:
\begin{center}
$S: \{0, 1\}^{512} \rightarrow \{0, 1\}^{512}$\\
$S(a)=S(a_{63} || \dots || a_0) = Pi(a_{63}) || \dots || Pi(a_0)$
\end{center}
\item Преобразование P:
\begin{center}
$P: \{0, 1\}^{512} \rightarrow \{0, 1\}^{512}$\\
$P(a)=P(a_{63} || \dots || a_0) =a_{Tau(63)} || \dots || a_{Tau(0)}$
\end{center}
$Tau$ представлен в \textbf{Приложении А}
\item Преобразование L:
\begin{center}
$L: \{0, 1\}^{512} \rightarrow \{0, 1\}^{512}$\\
$L(a)=L(a_7 || \dots || a_0) = l(a_7) || \dots || l(a_0)$
\end{center}
\item Преобразование Pi:
\begin{center}
$Pi: \{0, 1\}^8 \rightarrow \{0, 1\}^8$\\
\end{center}
Входное битовое сообщение переводим в десятичную систему счисления, затем из массива Pi' (представлен в \textbf{Приложении А}) берем соответствующий элемент и переводим его обратно в двоичное представление.
\item Преобразование l:
\begin{center}
$l: \{0, 1\}^{64} \rightarrow \{0, 1\}^{64}$
\end{center}
Выбираем строки матрицы A (представлена в \textbf{Приложении А}) с такими номерами, что соответствующие этим номерам биты входящего сообщения имеют ''1'', и ко всем этим строкам применяем преобразование X.\\
\end{itemize}
Тогда функцию round(h, m, N)
\begin{center}
round(h, m, N): $\{0, 1\}^{512} \times \{0, 1\}^{512} \times \{0, 1\}^{512} \rightarrow \{0, 1\}^{512}$
\end{center}
определим следующим образом:
\begin{center}
round(h, m, N) = X(X(E(LPSX(h, N), m), h), m), где\\
E(K, m) = $X(K_{13}, LPSX(K_{12}, \dots (K_2, LPSX(K_1, m))))$ и\\
$K_1 = K$,\\
$K_i = LPSX(K_{i-1}, C[i-1]), i = 2, \dots , 13$
\end{center}